From e1e64495da1226345c65f3e1b04ef489ba4988e4 Mon Sep 17 00:00:00 2001
From: Sami Farin <hvtaifwkbgefbaei@gmail.com>
Date: Thu, 16 Jan 2025 20:53:01 +0200
Subject: [PATCH] replace deprecated av_rdft_init with av_tx_init

THANKS ChatGPT
---
 src/spek-fft.cc | 61 +++++++++++++++++++++++++++++++++++--------------
 1 file changed, 44 insertions(+), 17 deletions(-)

diff --git a/src/spek-fft.cc b/src/spek-fft.cc
index 3105213f..0e682c45 100644
--- a/src/spek-fft.cc
+++ b/src/spek-fft.cc
@@ -2,7 +2,7 @@
 
 #define __STDC_CONSTANT_MACROS
 extern "C" {
-#include <libavcodec/avfft.h>
+#include <libavutil/tx.h>
 }
 
 #include "spek-fft.h"
@@ -16,35 +16,62 @@ class FFTPlanImpl : public FFTPlan
     void execute() override;
 
 private:
-    struct RDFTContext *cx;
+    AVTXContext *cx;
+    av_tx_fn tx_fn;
 };
 
-std::unique_ptr<FFTPlan> FFT::create(int nbits)
-{
+
+std::unique_ptr<FFTPlan> FFT::create(int nbits) {
     return std::unique_ptr<FFTPlan>(new FFTPlanImpl(nbits));
 }
 
-FFTPlanImpl::FFTPlanImpl(int nbits) : FFTPlan(nbits), cx(av_rdft_init(nbits, DFT_R2C))
-{
+FFTPlanImpl::FFTPlanImpl(int nbits) : FFTPlan(nbits), cx(nullptr), tx_fn(nullptr) {
+    int len = 1 << nbits;  // Length of the transform
+    int ret = av_tx_init(&cx, &tx_fn, AV_TX_FLOAT_RDFT, 0 /* forward transform */, len, nullptr, 0);
+    if (ret < 0) {
+        // Handle error (e.g., throw an exception or log the failure)
+        cx = nullptr;
+    }
 }
 
-FFTPlanImpl::~FFTPlanImpl()
-{
-    av_rdft_end(this->cx);
+FFTPlanImpl::~FFTPlanImpl() {
+    if (cx) {
+        av_tx_uninit(&cx);  // Proper cleanup for av_tx_init
+        av_free(cx);
+    }
 }
 
-void FFTPlanImpl::execute()
-{
-    av_rdft_calc(this->cx, this->get_input());
+void FFTPlanImpl::execute() {
+    if (!tx_fn || !cx) {
+        // Handle the case where initialization failed
+        return;
+    }
 
-    // Calculate magnitudes.
     int n = this->get_input_size();
     float n2 = n * n;
-    this->set_output(0, 10.0f * log10f(this->get_input(0) * this->get_input(0) / n2));
-    this->set_output(n / 2, 10.0f * log10f(this->get_input(1) * this->get_input(1) / n2));
+
+    // Input and output buffers
+    float *input = this->get_input();
+    size_t output_size = 2 * ((n / 2) + 1) * sizeof(float);
+    float *output = static_cast<float *>(av_malloc(output_size));
+    if (!output) {
+        // Handle memory allocation failure
+        return;
+    }
+
+    // Perform the transform
+    tx_fn(cx, output, input, sizeof(float));
+
+    // Calculate magnitudes and set the output
+    this->set_output(0, 10.0f * log10f(output[0] * output[0] / n2));
+    this->set_output(n / 2, 10.0f * log10f(output[1] * output[1] / n2));
     for (int i = 1; i < n / 2; i++) {
-        float re = this->get_input(i * 2);
-        float im = this->get_input(i * 2 + 1);
+        float re = output[i * 2];
+        float im = output[i * 2 + 1];
         this->set_output(i, 10.0f * log10f((re * re + im * im) / n2));
     }
+
+    // Cleanup the output buffer
+    av_free(output);
 }
+
