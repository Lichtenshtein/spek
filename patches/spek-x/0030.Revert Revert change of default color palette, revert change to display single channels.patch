From d9aca46f7fad6b9ca9d9873e131e68b327408346 Mon Sep 17 00:00:00 2001
From: MikeWang000000 <mikewang000000@gmail.com>
Date: Mon, 23 Jan 2023 01:35:44 +0800
Subject: [PATCH] Revert "Revert change of default color palette, revert change
 to display single channels"

This reverts commit 148e82adddff0e7f191b0ec6b7cd62910a919a5e.
---
 src/spek-audio.cc       | 93 ++++++++++++++++++++++-------------------
 src/spek-audio.h        |  2 +-
 src/spek-pipeline.cc    | 27 ++++++------
 src/spek-pipeline.h     |  2 +
 src/spek-spectrogram.cc |  5 +++
 src/spek-spectrogram.h  |  2 +
 6 files changed, 73 insertions(+), 58 deletions(-)

diff --git a/src/spek-audio.cc b/src/spek-audio.cc
index 837dcf5..48f2aae 100644
--- a/src/spek-audio.cc
+++ b/src/spek-audio.cc
@@ -1,3 +1,5 @@
+#include <assert.h>
+
 extern "C" {
 #define __STDC_CONSTANT_MACROS
 #define __STDC_LIMIT_MACROS
@@ -17,7 +19,7 @@ class AudioFileImpl : public AudioFile
         int bits_per_sample, int streams, int channels, double duration
     );
     ~AudioFileImpl() override;
-    void start(int samples) override;
+    void start(int channel, int samples) override;
     int read() override;
 
     AudioError get_error() const override { return this->error; }
@@ -46,6 +48,8 @@ class AudioFileImpl : public AudioFile
     int channels;
     double duration;
 
+    int channel;
+
     AVPacket *packet;
     int offset;
     AVFrame *frame;
@@ -249,8 +253,14 @@ AudioFileImpl::~AudioFileImpl()
     }
 }
 
-void AudioFileImpl::start(int samples)
+void AudioFileImpl::start(int channel, int samples)
 {
+    this->channel = channel;
+    if (channel < 0 || channel >= this->channels) {
+        assert(false);
+        this->error = AudioError::NO_CHANNELS;
+    }
+
     AVStream *stream = this->format_context->streams[this->audio_stream];
     int64_t rate = this->sample_rate * (int64_t)stream->time_base.num;
     int64_t duration = (int64_t)(this->duration * stream->time_base.den / stream->time_base.num);
@@ -285,57 +295,52 @@ int AudioFileImpl::read()
             this->offset += len;
             // We have data, return it and come back for more later.
             int samples = this->frame->nb_samples;
-            int channels = this->channels;
-            int buffer_len = samples * channels;
-            if (buffer_len > this->buffer_len) {
+            if (samples > this->buffer_len) {
                 this->buffer = static_cast<float*>(
-                    av_realloc(this->buffer, buffer_len * sizeof(float))
+                    av_realloc(this->buffer, samples * sizeof(float))
                 );
-                this->buffer_len = buffer_len;
+                this->buffer_len = samples;
             }
 
             AVSampleFormat format = static_cast<AVSampleFormat>(this->frame->format);
             int is_planar = av_sample_fmt_is_planar(format);
-            int i = 0;
             for (int sample = 0; sample < samples; ++sample) {
-                for (int channel = 0; channel < channels; ++channel) {
-                    uint8_t *data;
-                    int offset;
-                    if (is_planar) {
-                        data = this->frame->data[channel];
-                        offset = sample;
-                    } else {
-                        data = this->frame->data[0];
-                        offset = i;
-                    }
-                    float value;
-                    switch (format) {
-                    case AV_SAMPLE_FMT_S16:
-                    case AV_SAMPLE_FMT_S16P:
-                        value = reinterpret_cast<int16_t*>(data)[offset]
-                            / static_cast<float>(INT16_MAX);
-                        break;
-                    case AV_SAMPLE_FMT_S32:
-                    case AV_SAMPLE_FMT_S32P:
-                        value = reinterpret_cast<int32_t*>(data)[offset]
-                            / static_cast<float>(INT32_MAX);
-                        break;
-                    case AV_SAMPLE_FMT_FLT:
-                    case AV_SAMPLE_FMT_FLTP:
-                        value = reinterpret_cast<float*>(data)[offset];
-                        break;
-                    case AV_SAMPLE_FMT_DBL:
-                    case AV_SAMPLE_FMT_DBLP:
-                        value = reinterpret_cast<double*>(data)[offset];
-                        break;
-                    default:
-                        value = 0.0f;
-                        break;
-                    }
-                    this->buffer[i++] = value;
+                uint8_t *data;
+                int offset;
+                if (is_planar) {
+                    data = this->frame->data[this->channel];
+                    offset = sample;
+                } else {
+                    data = this->frame->data[0];
+                    offset = sample * this->channels;
+                }
+                float value;
+                switch (format) {
+                case AV_SAMPLE_FMT_S16:
+                case AV_SAMPLE_FMT_S16P:
+                    value = reinterpret_cast<int16_t*>(data)[offset]
+                        / static_cast<float>(INT16_MAX);
+                    break;
+                case AV_SAMPLE_FMT_S32:
+                case AV_SAMPLE_FMT_S32P:
+                    value = reinterpret_cast<int32_t*>(data)[offset]
+                        / static_cast<float>(INT32_MAX);
+                    break;
+                case AV_SAMPLE_FMT_FLT:
+                case AV_SAMPLE_FMT_FLTP:
+                    value = reinterpret_cast<float*>(data)[offset];
+                    break;
+                case AV_SAMPLE_FMT_DBL:
+                case AV_SAMPLE_FMT_DBLP:
+                    value = reinterpret_cast<double*>(data)[offset];
+                    break;
+                default:
+                    value = 0.0f;
+                    break;
                 }
+                this->buffer[sample] = value;
             }
-            return buffer_len;
+            return samples;
         }
         if (this->packet->data) {
             this->packet->data -= this->offset;
diff --git a/src/spek-audio.h b/src/spek-audio.h
index e6af46a..53e3cdf 100644
--- a/src/spek-audio.h
+++ b/src/spek-audio.h
@@ -21,7 +21,7 @@ class AudioFile
 public:
     virtual ~AudioFile() {}
 
-    virtual void start(int samples) = 0;
+    virtual void start(int channel, int samples) = 0;
     virtual int read() = 0;
 
     virtual AudioError get_error() const = 0;
diff --git a/src/spek-pipeline.cc b/src/spek-pipeline.cc
index 9f5d4c2..af9683d 100644
--- a/src/spek-pipeline.cc
+++ b/src/spek-pipeline.cc
@@ -27,6 +27,7 @@ struct spek_pipeline
     std::unique_ptr<AudioFile> file;
     std::unique_ptr<FFTPlan> fft;
     int stream;
+    int channel;
     enum window_function window_function;
     int samples;
     spek_pipeline_cb cb;
@@ -64,6 +65,7 @@ struct spek_pipeline * spek_pipeline_open(
     std::unique_ptr<AudioFile> file,
     std::unique_ptr<FFTPlan> fft,
     int stream,
+    int channel,
     enum window_function window_function,
     int samples,
     spek_pipeline_cb cb,
@@ -74,6 +76,7 @@ struct spek_pipeline * spek_pipeline_open(
     p->file = std::move(file);
     p->fft = std::move(fft);
     p->stream = stream;
+    p->channel = channel;
     p->window_function = window_function;
     p->samples = samples;
     p->cb = cb;
@@ -99,7 +102,7 @@ struct spek_pipeline * spek_pipeline_open(
         p->input_size = p->nfft * (NFFT * 2 + 1);
         p->input = (float*)malloc(p->input_size * sizeof(float));
         p->output = (float*)malloc(p->fft->get_output_size() * sizeof(float));
-        p->file->start(samples);
+        p->file->start(channel, samples);
     }
 
     return p;
@@ -200,8 +203,8 @@ std::string spek_pipeline_desc(const struct spek_pipeline *pipeline)
     if (pipeline->file->get_channels()) {
         items.push_back(std::string(
             wxString::Format(
-                ngettext("%d channel", "%d channels", pipeline->file->get_channels()),
-                pipeline->file->get_channels()
+                // TRANSLATORS: first %d is the current channel, second %d is the total number.
+                "channel %d / %d", pipeline->channel + 1, pipeline->file->get_channels()
             ).utf8_str()
         ));
     }
@@ -298,6 +301,11 @@ int spek_pipeline_streams(const struct spek_pipeline *pipeline)
     return pipeline->file->get_streams();
 }
 
+int spek_pipeline_channels(const struct spek_pipeline *pipeline)
+{
+    return pipeline->file->get_channels();
+}
+
 double spek_pipeline_duration(const struct spek_pipeline *pipeline)
 {
     return pipeline->file->get_duration();
@@ -318,20 +326,13 @@ static void * reader_func(void *pp)
     }
 
     int pos = 0, prev_pos = 0;
-    int channels = p->file->get_channels();
     int len;
     while ((len = p->file->read()) > 0) {
         if (p->quit) break;
 
         const float *buffer = p->file->get_buffer();
-        while (len >= channels) {
-            float val = 0.0f;
-            for (int i = 0; i < channels; i++) {
-                val += buffer[i];
-            }
-            p->input[pos] = val / channels;
-            buffer += channels;
-            len -= channels;
+        while (len-- > 0) {
+            p->input[pos] = *buffer++;
             pos = (pos + 1) % p->input_size;
 
             // Wake up the worker if we have enough data.
@@ -339,7 +340,7 @@ static void * reader_func(void *pp)
                 reader_sync(p, prev_pos = pos);
             }
         }
-        assert(len == 0);
+        assert(len == -1);
     }
 
     if (pos != prev_pos) {
diff --git a/src/spek-pipeline.h b/src/spek-pipeline.h
index 8a6562c..b127f18 100644
--- a/src/spek-pipeline.h
+++ b/src/spek-pipeline.h
@@ -21,6 +21,7 @@ struct spek_pipeline * spek_pipeline_open(
     std::unique_ptr<AudioFile> file,
     std::unique_ptr<FFTPlan> fft,
     int stream,
+    int channel,
     enum window_function window_function,
     int samples,
     spek_pipeline_cb cb,
@@ -32,5 +33,6 @@ void spek_pipeline_close(struct spek_pipeline *pipeline);
 
 std::string spek_pipeline_desc(const struct spek_pipeline *pipeline);
 int spek_pipeline_streams(const struct spek_pipeline *pipeline);
+int spek_pipeline_channels(const struct spek_pipeline *pipeline);
 double spek_pipeline_duration(const struct spek_pipeline *pipeline);
 int spek_pipeline_sample_rate(const struct spek_pipeline *pipeline);
diff --git a/src/spek-spectrogram.cc b/src/spek-spectrogram.cc
index c596df4..0e08c12 100644
--- a/src/spek-spectrogram.cc
+++ b/src/spek-spectrogram.cc
@@ -49,6 +49,8 @@ SpekSpectrogram::SpekSpectrogram(wxFrame *parent) :
     pipeline(NULL),
     streams(0),
     stream(0),
+    channels(0),
+    channel(0),
     window_function(WINDOW_DEFAULT),
     duration(0.0),
     sample_rate(0),
@@ -76,6 +78,7 @@ void SpekSpectrogram::open(const wxString& path, const wxString& pngpath)
     this->path = path;
     this->pngpath = pngpath;
     this->stream = 0;
+    this->channel = 0;
     start();
     Refresh();
 }
@@ -417,6 +420,7 @@ void SpekSpectrogram::start()
             this->audio->open(std::string(this->path.utf8_str()), this->stream),
             this->fft->create(this->fft_bits),
             this->stream,
+            this->channel,
             this->window_function,
             samples,
             pipeline_cb,
@@ -426,6 +430,7 @@ void SpekSpectrogram::start()
         // TODO: extract conversion into a utility function.
         this->desc = wxString::FromUTF8(spek_pipeline_desc(this->pipeline).c_str());
         this->streams = spek_pipeline_streams(this->pipeline);
+        this->channels = spek_pipeline_channels(this->pipeline);
         this->duration = spek_pipeline_duration(this->pipeline);
         this->sample_rate = spek_pipeline_sample_rate(this->pipeline);
     } else {
diff --git a/src/spek-spectrogram.h b/src/spek-spectrogram.h
index a303df3..430a70f 100644
--- a/src/spek-spectrogram.h
+++ b/src/spek-spectrogram.h
@@ -51,6 +51,8 @@ class SpekSpectrogram : public wxWindow
     spek_pipeline *pipeline;
     int streams;
     int stream;
+    int channels;
+    int channel;
     enum window_function window_function;
     wxString path;
     wxString pngpath;
