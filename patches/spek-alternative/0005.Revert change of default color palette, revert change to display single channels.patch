From 148e82adddff0e7f191b0ec6b7cd62910a919a5e Mon Sep 17 00:00:00 2001
From: withmorten <morten.with@gmail.com>
Date: Thu, 6 Jul 2017 15:05:32 +0200
Subject: [PATCH] Revert change of default color palette, revert change to
 display single channels

---
 src/spek-audio.cc       | 93 +++++++++++++++++++----------------------
 src/spek-audio.h        |  2 +-
 src/spek-palette.h      |  2 +-
 src/spek-pipeline.cc    | 27 ++++++------
 src/spek-pipeline.h     |  2 -
 src/spek-spectrogram.cc | 15 -------
 src/spek-spectrogram.h  |  2 -
 7 files changed, 59 insertions(+), 84 deletions(-)

diff --git a/src/spek-audio.cc b/src/spek-audio.cc
index bc4bc463..f3893c18 100644
--- a/src/spek-audio.cc
+++ b/src/spek-audio.cc
@@ -1,5 +1,3 @@
-#include <assert.h>
-
 extern "C" {
 #define __STDC_CONSTANT_MACROS
 #define __STDC_LIMIT_MACROS
@@ -19,7 +17,7 @@ class AudioFileImpl : public AudioFile
         int streams, int channels, double duration
     );
     ~AudioFileImpl() override;
-    void start(int channel, int samples) override;
+    void start(int samples) override;
     int read() override;
 
     AudioError get_error() const override { return this->error; }
@@ -47,8 +45,6 @@ class AudioFileImpl : public AudioFile
     int channels;
     double duration;
 
-    int channel;
-
     AVPacket packet;
     int offset;
     AVFrame *frame;
@@ -247,14 +243,8 @@ AudioFileImpl::~AudioFileImpl()
     }
 }
 
-void AudioFileImpl::start(int channel, int samples)
+void AudioFileImpl::start(int samples)
 {
-    this->channel = channel;
-    if (channel < 0 || channel >= this->channels) {
-        assert(false);
-        this->error = AudioError::NO_CHANNELS;
-    }
-
     AVStream *stream = this->format_context->streams[this->audio_stream];
     int64_t rate = this->sample_rate * (int64_t)stream->time_base.num;
     int64_t duration = (int64_t)(this->duration * stream->time_base.den / stream->time_base.num);
@@ -288,52 +278,57 @@ int AudioFileImpl::read()
             }
             // We have data, return it and come back for more later.
             int samples = this->frame->nb_samples;
-            if (samples > this->buffer_len) {
+            int channels = this->channels;
+            int buffer_len = samples * channels;
+            if (buffer_len > this->buffer_len) {
                 this->buffer = static_cast<float*>(
-                    av_realloc(this->buffer, samples * sizeof(float))
+                    av_realloc(this->buffer, buffer_len * sizeof(float))
                 );
-                this->buffer_len = samples;
+                this->buffer_len = buffer_len;
             }
 
             AVSampleFormat format = static_cast<AVSampleFormat>(this->frame->format);
             int is_planar = av_sample_fmt_is_planar(format);
+            int i = 0;
             for (int sample = 0; sample < samples; ++sample) {
-                uint8_t *data;
-                int offset;
-                if (is_planar) {
-                    data = this->frame->data[this->channel];
-                    offset = sample;
-                } else {
-                    data = this->frame->data[0];
-                    offset = sample * this->channels;
-                }
-                float value;
-                switch (format) {
-                case AV_SAMPLE_FMT_S16:
-                case AV_SAMPLE_FMT_S16P:
-                    value = reinterpret_cast<int16_t*>(data)[offset]
-                        / static_cast<float>(INT16_MAX);
-                    break;
-                case AV_SAMPLE_FMT_S32:
-                case AV_SAMPLE_FMT_S32P:
-                    value = reinterpret_cast<int32_t*>(data)[offset]
-                        / static_cast<float>(INT32_MAX);
-                    break;
-                case AV_SAMPLE_FMT_FLT:
-                case AV_SAMPLE_FMT_FLTP:
-                    value = reinterpret_cast<float*>(data)[offset];
-                    break;
-                case AV_SAMPLE_FMT_DBL:
-                case AV_SAMPLE_FMT_DBLP:
-                    value = reinterpret_cast<double*>(data)[offset];
-                    break;
-                default:
-                    value = 0.0f;
-                    break;
+                for (int channel = 0; channel < channels; ++channel) {
+                    uint8_t *data;
+                    int offset;
+                    if (is_planar) {
+                        data = this->frame->data[channel];
+                        offset = sample;
+                    } else {
+                        data = this->frame->data[0];
+                        offset = i;
+                    }
+                    float value;
+                    switch (format) {
+                    case AV_SAMPLE_FMT_S16:
+                    case AV_SAMPLE_FMT_S16P:
+                        value = reinterpret_cast<int16_t*>(data)[offset]
+                            / static_cast<float>(INT16_MAX);
+                        break;
+                    case AV_SAMPLE_FMT_S32:
+                    case AV_SAMPLE_FMT_S32P:
+                        value = reinterpret_cast<int32_t*>(data)[offset]
+                            / static_cast<float>(INT32_MAX);
+                        break;
+                    case AV_SAMPLE_FMT_FLT:
+                    case AV_SAMPLE_FMT_FLTP:
+                        value = reinterpret_cast<float*>(data)[offset];
+                        break;
+                    case AV_SAMPLE_FMT_DBL:
+                    case AV_SAMPLE_FMT_DBLP:
+                        value = reinterpret_cast<double*>(data)[offset];
+                        break;
+                    default:
+                        value = 0.0f;
+                        break;
+                    }
+                    this->buffer[i++] = value;
                 }
-                this->buffer[sample] = value;
             }
-            return samples;
+            return buffer_len;
         }
         if (this->packet.data) {
             this->packet.data -= this->offset;
diff --git a/src/spek-audio.h b/src/spek-audio.h
index 53e3cdf2..e6af46a4 100644
--- a/src/spek-audio.h
+++ b/src/spek-audio.h
@@ -21,7 +21,7 @@ class AudioFile
 public:
     virtual ~AudioFile() {}
 
-    virtual void start(int channel, int samples) = 0;
+    virtual void start(int samples) = 0;
     virtual int read() = 0;
 
     virtual AudioError get_error() const = 0;
diff --git a/src/spek-palette.h b/src/spek-palette.h
index 27434def..4772e0e6 100644
--- a/src/spek-palette.h
+++ b/src/spek-palette.h
@@ -7,7 +7,7 @@ enum palette {
     PALETTE_SOX,
     PALETTE_MONO,
     PALETTE_COUNT,
-    PALETTE_DEFAULT = PALETTE_SOX,
+    PALETTE_DEFAULT = PALETTE_SPECTRUM,
 };
 
 uint32_t spek_palette(enum palette palette, double level);
diff --git a/src/spek-pipeline.cc b/src/spek-pipeline.cc
index 0cf2c190..aaa1cbca 100644
--- a/src/spek-pipeline.cc
+++ b/src/spek-pipeline.cc
@@ -26,7 +26,6 @@ struct spek_pipeline
     std::unique_ptr<AudioFile> file;
     std::unique_ptr<FFTPlan> fft;
     int stream;
-    int channel;
     enum window_function window_function;
     int samples;
     spek_pipeline_cb cb;
@@ -64,7 +63,6 @@ struct spek_pipeline * spek_pipeline_open(
     std::unique_ptr<AudioFile> file,
     std::unique_ptr<FFTPlan> fft,
     int stream,
-    int channel,
     enum window_function window_function,
     int samples,
     spek_pipeline_cb cb,
@@ -75,7 +73,6 @@ struct spek_pipeline * spek_pipeline_open(
     p->file = std::move(file);
     p->fft = std::move(fft);
     p->stream = stream;
-    p->channel = channel;
     p->window_function = window_function;
     p->samples = samples;
     p->cb = cb;
@@ -101,7 +98,7 @@ struct spek_pipeline * spek_pipeline_open(
         p->input_size = p->nfft * (NFFT * 2 + 1);
         p->input = (float*)malloc(p->input_size * sizeof(float));
         p->output = (float*)malloc(p->fft->get_output_size() * sizeof(float));
-        p->file->start(channel, samples);
+        p->file->start(samples);
     }
 
     return p;
@@ -202,8 +199,8 @@ std::string spek_pipeline_desc(const struct spek_pipeline *pipeline)
     if (pipeline->file->get_channels()) {
         items.push_back(std::string(
             wxString::Format(
-                // TRANSLATORS: first %d is the current channel, second %d is the total number.
-                "channel %d / %d", pipeline->channel + 1, pipeline->file->get_channels()
+                ngettext("%d channel", "%d channels", pipeline->file->get_channels()),
+                pipeline->file->get_channels()
             ).utf8_str()
         ));
     }
@@ -295,11 +292,6 @@ int spek_pipeline_streams(const struct spek_pipeline *pipeline)
     return pipeline->file->get_streams();
 }
 
-int spek_pipeline_channels(const struct spek_pipeline *pipeline)
-{
-    return pipeline->file->get_channels();
-}
-
 double spek_pipeline_duration(const struct spek_pipeline *pipeline)
 {
     return pipeline->file->get_duration();
@@ -320,13 +312,20 @@ static void * reader_func(void *pp)
     }
 
     int pos = 0, prev_pos = 0;
+    int channels = p->file->get_channels();
     int len;
     while ((len = p->file->read()) > 0) {
         if (p->quit) break;
 
         const float *buffer = p->file->get_buffer();
-        while (len-- > 0) {
-            p->input[pos] = *buffer++;
+        while (len >= channels) {
+            float val = 0.0f;
+            for (int i = 0; i < channels; i++) {
+                val += buffer[i];
+            }
+            p->input[pos] = val / channels;
+            buffer += channels;
+            len -= channels;
             pos = (pos + 1) % p->input_size;
 
             // Wake up the worker if we have enough data.
@@ -334,7 +333,7 @@ static void * reader_func(void *pp)
                 reader_sync(p, prev_pos = pos);
             }
         }
-        assert(len == -1);
+        assert(len == 0);
     }
 
     if (pos != prev_pos) {
diff --git a/src/spek-pipeline.h b/src/spek-pipeline.h
index b127f184..8a6562cb 100644
--- a/src/spek-pipeline.h
+++ b/src/spek-pipeline.h
@@ -21,7 +21,6 @@ struct spek_pipeline * spek_pipeline_open(
     std::unique_ptr<AudioFile> file,
     std::unique_ptr<FFTPlan> fft,
     int stream,
-    int channel,
     enum window_function window_function,
     int samples,
     spek_pipeline_cb cb,
@@ -33,6 +32,5 @@ void spek_pipeline_close(struct spek_pipeline *pipeline);
 
 std::string spek_pipeline_desc(const struct spek_pipeline *pipeline);
 int spek_pipeline_streams(const struct spek_pipeline *pipeline);
-int spek_pipeline_channels(const struct spek_pipeline *pipeline);
 double spek_pipeline_duration(const struct spek_pipeline *pipeline);
 int spek_pipeline_sample_rate(const struct spek_pipeline *pipeline);
diff --git a/src/spek-spectrogram.cc b/src/spek-spectrogram.cc
index de27beb0..1b321c9c 100644
--- a/src/spek-spectrogram.cc
+++ b/src/spek-spectrogram.cc
@@ -49,8 +49,6 @@ SpekSpectrogram::SpekSpectrogram(wxFrame *parent) :
     pipeline(NULL),
     streams(0),
     stream(0),
-    channels(0),
-    channel(0),
     window_function(WINDOW_DEFAULT),
     duration(0.0),
     sample_rate(0),
@@ -77,7 +75,6 @@ void SpekSpectrogram::open(const wxString& path)
 {
     this->path = path;
     this->stream = 0;
-    this->channel = 0;
     start();
     Refresh();
 }
@@ -94,16 +91,6 @@ void SpekSpectrogram::save(const wxString& path)
 void SpekSpectrogram::on_char(wxKeyEvent& evt)
 {
     switch (evt.GetKeyCode()) {
-    case 'c':
-        if (this->channels) {
-            this->channel = (this->channel + 1) % this->channels;
-        }
-        break;
-    case 'C':
-        if (this->channels) {
-            this->channel = (this->channel - 1 + this->channels) % this->channels;
-        }
-        break;
     case 'f':
         this->window_function = (enum window_function) ((this->window_function + 1) % WINDOW_COUNT);
         break;
@@ -394,7 +381,6 @@ void SpekSpectrogram::start()
             this->audio->open(std::string(this->path.utf8_str()), this->stream),
             this->fft->create(this->fft_bits),
             this->stream,
-            this->channel,
             this->window_function,
             samples,
             pipeline_cb,
@@ -404,7 +390,6 @@ void SpekSpectrogram::start()
         // TODO: extract conversion into a utility function.
         this->desc = wxString::FromUTF8(spek_pipeline_desc(this->pipeline).c_str());
         this->streams = spek_pipeline_streams(this->pipeline);
-        this->channels = spek_pipeline_channels(this->pipeline);
         this->duration = spek_pipeline_duration(this->pipeline);
         this->sample_rate = spek_pipeline_sample_rate(this->pipeline);
     } else {
diff --git a/src/spek-spectrogram.h b/src/spek-spectrogram.h
index 7e6b38c9..206f9457 100644
--- a/src/spek-spectrogram.h
+++ b/src/spek-spectrogram.h
@@ -37,8 +37,6 @@ class SpekSpectrogram : public wxWindow
     spek_pipeline *pipeline;
     int streams;
     int stream;
-    int channels;
-    int channel;
     enum window_function window_function;
     wxString path;
     wxString desc;
